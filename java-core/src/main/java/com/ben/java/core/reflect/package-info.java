/**
 * [Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载,Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。]
 *  
 *  
 * 成员:包括成员属性和成员方法
 * 静态成员:包括静态静态成员属性和静态成员方法[static修饰]
 * 只要是第一次对类的static成员引用就会触发类加载的整个过程,在这个过程中如果有static语句,会执行static语句块,并且永远只会执行一次;
 * 
 * 对应类的Class对象
 * 
 * 编译异常和运行时异常[以后采用这种术语]:
 * 
 * final:常量
 * static:静态
 * static final:静态常量
 * 
 ********************************************************************************************************************
 * 
 * 深入理解Java类型信息(Class对象)与反射机制[我们编译好的.class文件就是一个Class类型对象]
 * [Class类型类,它的对象保存的是某个具体的java类的信息]
 * 一.深入理解Class对象
 * 
 *	1.RTTI(Run-Time Type Identification)运行时类型识别:其作用是在运行时识别一个对象的类型和类的信息;
 *		1.1 传统的"RTTI":它假定我们在编译期已知道了所有类型(在没有反射机制创建和使用类对象时,一般都是编译期已确定其类型,如new对象时该类必须已定义好);
 *		1.2 反射机制:它允许我们在运行时发现和使用类型的信息[可以动态的创建对象],在Java中用来表示运行时类型信息的对应类就是Class类,Class类也是一个实实在在的类;
 *
 *  2.Class类被创建后的对象就是Class对象,注意,Class对象表示的是我们自己手动编写类的类型信息,比如创建一个Shapes类,那么JVM就会创建一个Shapes对应Class类的
 *    的Class对象,该Class对象保存了Shapes类相关的类型信息,实际上在Java中每个类都有一个Class对象,每当我们编写并且编译一个新创建的类就是产生一个对应Class对象
 *    并且这个Class对象会被保存在同名.class文件里(编译后的字节码文件保存的就是Class对象),那为什么需要这样一个Class对象呢?是这样的,当我们new一个新对象或者引用
 *    静态成员变量时,Java虚拟机(JVM)中的类加载器子系统会将对应Class对象加载到JVM中,然后JVM再根据这个类型信息相关的Class对象创建我们需要的实例对象或者提供静态
 *    变量的引用值.需要特别注意的是,手动编写的每个类,无论创建了多少个实例对象,在JVM中都只有一个Class对象,即在内存中每个类有且只有一个相对应的Class对象;
 *
 *	3.Class对象的加载 [第一次使用是加载,动态加载 ,按需加载]      [static语句会在类(Class对象)第一次被加载时执行,通过该语句我们可以知道类在什么时候被加载 *****]
 *		什么时候加载Class对象[即.class字节码文件]:当程序创建第一个对类的静态成员引用时,就会动态加载这个被使用的类[Class对象];注意,使用new操作符创建的新实例对象也会被当做对
 *		类的静态成员的成员的引用(构造函数也是类的静态方法)
 *		
 *	4.通过Java字面常量获取对应的Class对象: Class c1 = java.util.Date.class;
 *	  这种方式相对前面两种方法更加简单,安全.因为它在编译时就会收到编译器的检查同时由于无需调用forName()方法效率也会更高,因为通过字面量的方法获取Class对象的引用不会自动初始化该类[*****]
 *	同时字面常量获取Class对象的引用方式不仅可以应用于普通的类,也可以应用于接口,数组以及基本数据类型,这点在反射技术应用传递参数时很有帮助;由于基本数据类型还有对应的包装类型,
 *	其包装类型哟一个标准字段TYPE,而这个TYPE就是一个引用,指向基本数据类型的Class对象,一般情况下更倾向于使用.class的形式,这样可以保持与普通类的形式统一;		
 *
 *	5.三种获取Class对象的方式
 *		5.1  获取Class对象引用的方式3种，通过继承自Object类的getClass方法，Class类的静态方法forName以及字面常量的方式”.class”。
 *		5.2  其中实例类的getClass方法和Class类的静态方法forName都将会触发类的初始化阶段，而字面常量获取Class对象的方式则不会触发初始化。
 *		5.3  初始化是类加载的最后一个阶段，也就是说完成这个阶段后类也就加载到内存中(Class对象在加载阶段已被创建)，此时可以对类进行各种必要的操作了（如new对象，调用静态成员等），
 *		注意在这个阶段，才真正开始执行类中定义的Java程序代码或者字节码。
 *			[初始化：类加载最后阶段，若该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化成员变量。]
 *
 *	6.关于类加载的初始化阶段，在虚拟机规范严格规定了有且只有5种场景必须对类进行初始化：
 *		6.1 使用new关键字实例化对象时、读取或者设置一个类的静态字段(不包含编译期常量)以及调用静态方法的时候，必须触发类加载的初始化过程(类加载过程最终阶段)。
 *		6.2 使用反射包(java.lang.reflect)的方法对类进行反射调用时，如果类还没有被初始化，则需先进行初始化，这点对反射很重要。
 *		6.3 当初始化一个类的时候，如果其父类还没进行初始化则需先触发其父类的初始化。
 *		6.4 当Java虚拟机启动时，用户需要指定一个要执行的主类(包含main方法的类)，虚拟机会先初始化这个主类
 *		6.5 当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle 实例最后解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，
 *		          并且这个方法句柄对应类没有初始化时，必须触发其初始化(这点看不懂就算了，这是1.7的新增的动态语言支持，其关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，
 *		          这是一个比较大点的话题，这里暂且打住);
 *
 *	7.理解泛化的Class对象引用
 *		7.1 在Java SE5引入泛型后，我们可以利用泛型来表示Class对象更具体的类型，即使在运行期间会被擦除，但编译期足以确保我们使用正确的对象类型。
 *
 *		7.2 之所以可以强制转换,这得归功于RTTI,要知道在Java中,所有类型转换都是在运行时进行正确性检查的,利用RTTI判断类型是否正确从而确保强制转换的完成,
 *		          如果类型转换失败,将会抛出类型转换异常;
 *
 *二.反射机制
 *	1. 反射机制是在运行状态中,
 *					对于任意一个类,都能够知道这个类的的所有属性和方法,
 *					对于任意一个对象,都能够调用他的任意一个方法和属性,
 *													  这种动态获取类信息以及动态调用对象方法和属性的功能称为java语言的反射机制;
 *	一直以来反射技术都是Java中的闪亮点，这也是目前大部分框架(如Spring/Mybatis等)得以实现的支柱。在Java中，Class类与java.lang.reflect类库一起对反射技术进行了全力的支持[*****]。
 *	在反射包中，我们常用的类主要有Constructor类表示的是Class 对象所表示的类的构造方法，利用它可以在运行时动态创建对象、Field表示Class对象所表示的类的成员变量，
 *	通过它可以在运行时动态修改成员变量的属性值(包含private)、Method表示Class对象所表示的类的成员方法，通过它可以动态调用对象的方法(包含private);
 *
 *	[利用好Class类和Constructor类，我们可以在运行时动态创建任意对象，从而突破必须在编译期知道确切类型的障碍]
 *	需要特别注意的是被final关键字修饰的Field字段是安全的，在运行时可以接收任何修改，但最终其实际值是不会发生改变的。
 *
 *	在Java的java.lang.reflect包中存在着一个可以动态操作数组的类，Array，它提供了动态创建和访问 Java 数组的方法。
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 
 */
/**
 * @author ben xia
 * @date   2019年2月28日上午10:21:13
 */
package com.ben.java.core.reflect;