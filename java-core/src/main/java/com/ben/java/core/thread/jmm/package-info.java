/**
 * https://blog.csdn.net/javazejian/article/details/72772461
 * 
 * 1.JVM内存关键划分: stack,heap,Method Area(方法区属于线程共享的内存区域，又称Non-Heap(非堆))
 * 		方法区:方法区属于线程共享的内存区域，又称Non-Heap（非堆）,主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据;
 * 			 值得注意的是在方法区中存在一个叫运行时常量池(Runtime Constant Pool）的区域，它主要用于存放编译器生成的各种字面量和符号引用，
 * 			这些内容将在类加载后存放到运行时常量池中，以便后续使用。
 * 
 * 		JVM堆: Java堆也是属于线程共享的内存区域，它在虚拟机启动时创建;
 * 		JVM栈: 线程私有内存区域;
 * 
 * 2.Java内存模型(即Java Memory Model，简称JMM)
 * 	    由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，
 * 	 而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，
 * 	 首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，
 * 	 工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，
 *   线程间的通信(传值)必须通过主内存来完成;[主内存:线程共享的内存区域包括方法区,堆区;工作区内存:线程私有内存区域]
 * 
 *   根据虚拟机规范，对于一个实例对象中的成员方法而言，如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），
 *   将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，而对象实例将存储在主内存(共享数据区域，堆)中。
 *   但对于实例对象的成员变量，不管它是基本数据类型或者包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。
 *   至于static变量以及类本身相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘若两个线程同时调用了同一个对象的同一个方法，
 *   那么两条线程会将要操作的数据拷贝一份到自己的工作内存中，执行完成操作后才刷新到主内存;
 *
 * 3.硬件内存架构
 * 		CPU中的4核[核心]8线程: 一个内核对应一个计算引擎;
 * 		
 * 	从多线程的调度来说，每个线程都会映射到各个CPU核心中并行运行。在CPU内部有一组CPU寄存器，寄存器是cpu直接访问和处理的数据，是一个临时放数据的空间。
 * 	一般CPU都会从内存取数据到寄存器，然后进行处理，但由于内存的处理速度远远低于CPU，导致CPU在处理指令时往往花费很多时间在等待内存做准备工作，
 * 	于是在寄存器和主内存间添加了CPU缓存，CPU缓存比较小，但访问速度比主内存快得多，如果CPU总是操作主内存中的同一址地的数据，很容易影响CPU执行速度，
 * 	此时CPU缓存就可以把从内存提取的数据暂时保存起来，如果寄存器要取内存中同一位置的数据，直接从缓存中提取，无需直接从主内存取。
 * 需要注意的是，寄存器并不每次数据都可以从缓存中取得数据，万一不是同一个内存地址中的数据，那寄存器还必须直接绕过缓存从内存中取数据。
 * 所以并不每次都得到缓存中取数据，这种现象有个专业的名称叫做缓存的命中率，从缓存中取就命中，不从缓存中取从内存中取，就没命中，
 * 可见缓存命中率的高低也会影响CPU执行性能，这就是CPU、缓存以及主内存间的简要交互过程，
 * 总而言之当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存(当然如果CPU缓存中存在需要的数据就会直接从缓存获取)，进而在读取CPU缓存到寄存器，
 * 当CPU需要写数据到主存时，同样会先刷新寄存器中的数据到CPU缓存，然后再把数据刷新到主内存中。
 * 
 * 	 Java线程的实现是基于一对一的线程模型，所谓的一对一模型，实际上就是通过语言级别层面程序去间接调用系统内核的线程模型，即我们在使用Java线程时，
 *   Java虚拟机内部是转而调用当前操作系统的内核线程来完成当前任务。
 * 
 * 	 内核线程(Kernel-Level Thread，KLT)，它是由操作系统内核(Kernel)支持的线程，这种线程是由操作系统内核来完成线程切换，内核通过操作调度器进而对线程执行调度，
 *  并将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身,这也就是操作系统可以同时处理多任务的原因。
 * 
 * 多线程的执行最终都会映射到硬件处理器上进行执行，但Java内存模型和硬件内存架构并不完全一致。对于硬件内存来说只有寄存器、缓存内存、主内存的概念，
 * 并没有工作内存(线程私有数据区域)和主内存(堆内存)之分，也就是说Java内存模型对内存的划分对硬件内存并没有任何影响;
 * 
 * 4.Java内存模型的承诺:
 * 		原子性:指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响。
 * 			 [指令重排:编译器指令重排,处理器的指令重排(就是说程序不一定会按照代码的前后顺序执行),这些重排优化可能会导致程序出现内存可见性问题,指令重排可能导致程序乱序执行]
 * 			 [请记住，指令重排只会保证单线程中串行语义的执行的一致性，但并不会关心多线程间的语义一致性]
 *      可见性:可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值。
 *      有序性:在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，
 *      	   前半句指的是单线程内保证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。
 *      
 *      [除了JVM自身提供的对基本数据类型读写操作的原子性外，对于方法级别或者代码块级别的原子性操作，可以使用synchronized关键字或者重入锁(ReentrantLock)保证程序执行的原子性]
 *      [而工作内存与主内存同步延迟现象导致的可见性问题，可以使用synchronized关键字或者volatile关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见。]
 *      [对于指令重排导致的可见性问题和有序性问题，则可以利用volatile关键字解决，因为volatile的另外一个作用就是禁止重排序优化]
 *      
 * JMM内部还定义一套happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性;
 *(1)程序顺序原则:即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。
 *(2)锁规则: 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。
 *(3)volatile规则 :volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，
 *    而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。
 *(4)线程启动规则: 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见
 *(5)传递性: A先于B ，B先于C 那么A必然先于C
 *(6)线程终止规则 :线程的所有操作先于线程的终结，B.join()方法的作用是等待当前执行的线程B终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，
 *	     线程B对共享变量的修改将对线程A可见。
 *(7)线程中断规则: 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。
 *(8)对象终结规则: 对象的构造函数执行，结束先于finalize()方法
 * 
 * 
 * 	5.volatile内存语义
 * 		(a)可见性:保证被volatile修饰的共享变量对所有线程总是可见的，也就是指在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），
 * 		         所以其它线程会马上读取到已修改的值，关于工作内存和主内存可简单理解为高速缓存（直接与CPU打交道）和主存（日常所说的内存条），注意工作内存是线程独享的，主存是线程共享的。
 * 		        但是对于volatile变量运算操作在多线程环境并不保证安全性;
 * 		   [变量运算操作本身就是原子操作可以使用(boolean = true): volatile;变量运算操作本身不是原子操作需要使用(i++): synchronized;]
 * 		   [那么JMM是如何实现让volatile变量对其他线程立即可见的呢？实际上，当写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中，
 * 		          当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量。volatile变量正是通过这种写-读方式实现对其他线程可见
 * 		        （但其内存语义实现则是通过内存屏障，稍后会说明）。]
 *		(b)禁止指令重排序优化:我们写的代码（特别是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，
 * 			却不保证实际指令的顺序与源代码相同，这在单线程并没什么问题，然而一旦引入多线程环境，这种乱序就可能导致严重问题。
 * 
 *	        内存屏障(Memory Barrier)，又称内存栅栏，是一个CPU指令，它的作用有两个:
 *			一.是保证特定操作的执行顺序;
 *			二.是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，
 *			      不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用
 *			     是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。
 * 
 * 	6.final的内存语义[https://blog.csdn.net/dam454450872/article/details/80385520]
 * 		与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个重排序规则：
 *			1)在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。
 *			2)初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。
 * 
 * 		1)写final域的重排序规则:禁止把final域的写重排序到构造函数之外,具体包含两个方面:
 * 			1)JMM禁止编译器把final域的写重排序到构造函数之外;
 * 			2)编译器会在final域的写之后,构造函数return之前,插入一个StoreStore屏障.该屏障禁止处理器把final域的写重排序到构造函数之外;
 * 
 * 		2)读final域的重排序规则:在一个线程中,初次读对象引用与初次读该对象包含的final域,JMM禁止处理器在这两个操作之间重排序(仅仅针对处理器)
 * 						 编译器会在读final域操作的前面插入一个LoadLoad屏障;
 * 		初次读对象的引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。
 * 		大多数处理器也会遵守间接依赖，但有个别处理器允许对存在间接依赖关系的操作做重排序（如alpha处理器），所以说这个读final域的重排序规则就是专门针对这种处理器。
 * 
 * 		读final域的重排序规则可以确保在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。
 * 
 *  7.为什么final引用不能再构造函数内"逸出"[https://blog.csdn.net/dam454450872/article/details/80382545]
 *  	写final域的重排序规则可以确保：在引用变量为任意线程可见之前，读引用变量所指向对象的final域已经在构造函数中被正确初始化了。
 *  但是这里面，还需要另外一点的保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，即对象引用不能再构造函数中“逸出”;
 * 
 *  8.x86处理器，final域的读写不会插入任何内存屏障。
 * 
 *  9.增强final语义的意义:通过给final域增加写和读重排序规则,可以提供初始化安全保证,只要对象时正确构造的(被构造对象的引用在构造函数中没有"逸出"),
 *  				   就不需要使用同步也能保证任意线程都能看到这个final域在构造函数中被初始化后的值;
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 */
/**
 * @author Administrator
 *
 */
package com.ben.java.core.thread.jmm;